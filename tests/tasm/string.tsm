section text

    ; Arguments:
    ;   ESI: pointer to string
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: u32 length of the string
    strlen:
        push BL                 ; Backup BL
        pushdw EDI              ; Backup EDI
        mov EAX, 0              ; Create iterator
        mov EDI, ESI            ; Copy ESI to EDI

        __strlen_loop:
            lb BL, EDI          ; Read next character
            add BL, 0           ; Buffer BL for loop condition
            jz __strlen_end     ; Loop escape condition
            add EAX, 1          ; Increment iterator
            add EDI, 1          ; Increment EDI
            jmp __strlen_loop   ; Jmp to loop start

        __strlen_end:
            popdw EDI           ; Restore EDI
            pop BL              ; Restore BL
            ret                 ; Return

    ; Arguments:
    ;   ESI: pointer to string A
    ;   EAX: pointer to string B
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: 0 if A==B, < 0 if A < B, > 0 if A > B
    strcmp:
        pushdw EBX              ; Save EBX
        pushdw ECX              ; Save ECX
        pushdw EDX              ; Save EDX

        mov EBX, ESI            ; Move A to EBX
        mov ECX, EAX            ; Move B to ECX

        __strcmp_loop:
            xor EAX, EAX        ; Zero EAX
            xor EDX, EDX        ; Zero EDX

            lb AL, EBX          ; AL = *A
            lb DL, ECX          ; DL = *B

            sub EAX, EDX        ; *A - *B
            jnz __strcmp_end    ; If different, return

            xor EAX, EAX        ; Zero EAX
            lb AL, EBX          ; AL = *A
            add AL, 0           ; Check if *A == *B == 0
            jz __strcmp_end     ; If both are zero, return

            ; Otherwise, *A != 0 && *B != 0
            add EBX, 1          ; Increment ptr to A
            add ECX, 1          ; Increment ptr to B
            jmp __strcmp_loop   ; Reiterate

        __strcmp_end:
            popdw EDX               ; Restore EDX
            popdw ECX               ; Restore ECX
            popdw EBX               ; Restore EBX
            ret

    ; Determines whether or not a character is a numeric value
    ; Arguments:
    ;   EAX: the character to check
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: 0 if non-numeric, 1 if numeric
    isnum:
        cmp EAX, 48      ; '0' == 48
        jc __isnum_false ; EAX < '0'

        cmp EAX, 58       ; '9' + 1 == 58
        jnc __isnum_false ; EAX > '9'

        mov EAX, 1 ; '0' <= EAX <= '9'
        ret

        __isnum_false:
            mov EAX, 0
            ret

    ; Determines whether or not a character is a numeric value
    ; Arguments:
    ;   EAX: the character to check
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: 0 if non-numeric, 1 if numeric
    isspace:
        cmp EAX, 32         ; 32 == ' '
        jz __isspace_true   ; EAX == ' '

        cmp EAX, 9          ; ASCII 9 - 13
        jc __isspace_false  ; EAX < 9

        cmp EAX, 14         ; 13 + 1 == 14
        jnc __isspace_false ; EAX > 13

        __isspace_true:
            mov EAX, 1
            ret

        __isspace_false:
            mov EAX, 0
            ret

    ; Parses a strz to an unsigned integral value (u32)
    ; Arguments:
    ;   ESI: pointer to a null-terminated string
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: the u32 value of the number stored in ESI, up to the last numeric character (0-9)
    atoui:
        pushdw RP
        pushdw EBX
        pushdw ECX
        pushdw EDX

        mov EAX, 0      ; Placeholder
        xor EBX, EBX    ; Char/decimal buffer
        mov ECX, 10     ; Const (u32)10
        mov EDX, ESI    ; EDX = ESI

        __atoi_loop:
            ; Verify string is not terminated
            lb BL, EDX
            cmp BL, 0
            jz __atoi_end

            ; Verify char is numeric
            pushdw EAX
            mov EAX, EBX
            call isnum
            cmp EAX, 0
            popdw EAX
            jz __atoi_end

            ; Otherwise, parse
            pushdw EDX  ; Save EDX
            mul ECX     ; Shift decimal
            popdw EDX   ; Restore EDX after mul (discard high dword)
            sub BL, 48  ; 48 == '0'
            add EAX, EBX

            ; Increment & reiterate
            add EDX, 1
            jmp __atoi_loop

        __atoi_end:
            popdw EDX
            popdw ECX
            popdw EBX
            popdw RP
            ret

    ; Trims whitespace off both ends in place of a strz by calling rtrimstr then ltrimstr
    ; Arguments:
    ;   ESI: pointer to the strz
    ; Modifies:
    ;   ESI
    ; Returns:
    ;   ESI: pointer to the trimmed strz
    trimstr:
        pushdw RP       ; Save RP
        pushdw EDI      ; Save EDI
        call rtrimstr   ; Right-trim, modifies ESI in place
        call ltrimstr   ; Left-trim, sets EDI
        mov ESI, EDI    ; Move new ptr (EDI) to ESI
        popdw EDI       ; Restore EDI
        popdw RP        ; Restore RP
        ret

    ; Trims whitespace off the left end of a strz by moving the pointer
    ; Arguments:
    ;   ESI: pointer to the strz
    ; Modifies:
    ;   EDI
    ; Returns:
    ;   EDI: pointer to the new strz (shifted down from ESI)
    ltrimstr:
        ; Save regs
        pushdw RP
        pushdw EAX
        push BL
        pushdw EDX

        ; Position EDI to start of string
        mov EDI, ESI    ; EDI = ESI
        call strlen     ; strlen(ESI)
        mov EDX, EAX    ; EDX = strlen(ESI)

        ; while EDX > ESI
        __ltrimstr_loop:
            ; Check loop condition
            mov EAX, ESI        ; EAX = ESI
            add EAX, EDX        ; EAX = ESI + strlen
            cmp EAX, EDI        ; Check EAX - EDI
            jz __ltrimstr_end   ; EDI == ESI + strlen (at end of string)

            xor EAX, EAX        ; Zero EAX
            lb AL, EDI          ; AL = *EDI
            call isspace        ; isspace(AL)
            cmp EAX, 0          ; Check isspace(AL) == 0
            jz __ltrimstr_end   ; Not a space

            add EDI, 1          ; Increment EDI
            jmp __ltrimstr_loop ; Reiterate

        __ltrimstr_end:
            ; Restore regs
            popdw EDX
            pop BL
            popdw EAX
            popdw RP
            ret

    ; Trims whitespace off the right end of a strz in place
    ; Arguments:
    ;   ESI: pointer to the strz
    ; Modifies:
    ;   none
    ; Returns:
    ;   none
    rtrimstr:
        ; Save regs
        pushdw RP
        pushdw EAX
        push BL
        pushdw EDX

        ; Position EDX to end of string
        mov EDX, ESI    ; EDX = ESI
        call strlen     ; strlen(ESI)
        add EDX, EAX    ; EDX += strlen(ESI)
        sub EDX, 1      ; EDX -= 1

        ; while EDX > ESI
        __rtrimstr_loop:
            ; Check loop condition
            cmp EDX, ESI        ; Check EDX - ESI
            jc __rtrimstr_end   ; EDX < ESI

            xor EAX, EAX        ; Zero EAX
            lb AL, EDX          ; AL = *EDX
            call isspace        ; isspace(AL)
            cmp EAX, 0          ; Check isspace(AL) == 0
            jz __rtrimstr_end   ; Not a space

            sub EDX, 1          ; Decrement EDX
            jmp __rtrimstr_loop ; Reiterate

        __rtrimstr_end:
            ; Put \0 at end of string
            mov BL, 0   ; BL = 0
            add EDX, 1  ; EDX += 1
            sb BL, EDX  ; *(EDX + 1) = 0

            ; Restore regs
            popdw EDX
            pop BL
            popdw EAX
            popdw RP
            ret
