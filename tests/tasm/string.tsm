section text

    ; Arguments:
    ;   ESI: pointer to string
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: u32 length of the string
    strlen:
        push BL                 ; Backup BL
        pushdw EDI              ; Backup EDI
        mov EAX, 0              ; Create iterator
        mov EDI, ESI            ; Copy ESI to EDI

        __strlen_loop:
            lb BL, EDI          ; Read next character
            add BL, 0           ; Buffer BL for loop condition
            jz __strlen_end     ; Loop escape condition
            add EAX, 1          ; Increment iterator
            add EDI, 1          ; Increment EDI
            jmp __strlen_loop   ; Jmp to loop start

        __strlen_end:
            popdw EDI           ; Restore EDI
            pop BL              ; Restore BL
            ret                 ; Return

    ; Arguments:
    ;   ESI: pointer to string A
    ;   EAX: pointer to string B
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: 0 if A==B, < 0 if A < B, > 0 if A > B
    strcmp:
        pushdw EBX              ; Save EBX
        pushdw ECX              ; Save ECX
        pushdw EDX              ; Save EDX

        mov EBX, ESI            ; Move A to EBX
        mov ECX, EAX            ; Move B to ECX

        __strcmp_loop:
            xor EAX, EAX        ; Zero EAX
            xor EDX, EDX        ; Zero EDX

            lb AL, EBX          ; AL = *A
            lb DL, ECX          ; DL = *B

            sub EAX, EDX        ; *A - *B
            jnz __strcmp_end    ; If different, return

            xor EAX, EAX        ; Zero EAX
            lb AL, EBX          ; AL = *A
            add AL, 0           ; Check if *A == *B == 0
            jz __strcmp_end     ; If both are zero, return

            ; Otherwise, *A != 0 && *B != 0
            add EBX, 1          ; Increment ptr to A
            add ECX, 1          ; Increment ptr to B
            jmp __strcmp_loop   ; Reiterate

        __strcmp_end:
            popdw EDX               ; Restore EDX
            popdw ECX               ; Restore ECX
            popdw EBX               ; Restore EBX
            ret

    ; Determines whether or not a character is a numeric value
    ; Arguments:
    ;   EAX: the character to check
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: 0 if non-numeric, 1 if numeric
    isnum:
        cmp EAX, 48      ; '0' == 48
        jc __isnum_false ; EAX < '0'

        cmp EAX, 58       ; '9' + 1 == 58
        jnc __isnum_false ; EAX > '9'

        mov EAX, 1 ; '0' <= EAX <= '9'
        ret

        __isnum_false:
            mov EAX, 0
            ret

    ; Determines whether or not a character is a numeric value
    ; Arguments:
    ;   EAX: the character to check
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: 0 if non-numeric, 1 if numeric
    isspace:
        cmp EAX, 32         ; 32 == ' '
        jz __isspace_true   ; EAX == ' '

        cmp EAX, 9          ; ASCII 9 - 13
        jc __isspace_false  ; EAX < 9

        cmp EAX, 14         ; 13 + 1 == 14
        jnc __isspace_false ; EAX > 13

        __isspace_true:
            mov EAX, 1
            ret

        __isspace_false:
            mov EAX, 0
            ret

    ; Parses a strz to an unsigned integral value (u32)
    ; Arguments:
    ;   ESI: pointer to a null-terminated string
    ; Modifies:
    ;   EAX
    ; Returns:
    ;   EAX: the u32 value of the number stored in ESI, up to the last numeric character (0-9)
    atoui:
        pushdw RP
        pushdw EBX
        pushdw ECX
        pushdw EDX

        mov EAX, 0      ; Placeholder
        xor EBX, EBX    ; Char/decimal buffer
        mov ECX, 10     ; Const (u32)10
        mov EDX, ESI    ; EDX = ESI

        __atoi_loop:
            ; Verify string is not terminated
            lb BL, EDX
            cmp BL, 0
            jz __atoi_end

            ; Verify char is numeric
            pushdw EAX
            mov EAX, EBX
            call isnum
            cmp EAX, 0
            popdw EAX
            jz __atoi_end

            ; Otherwise, parse
            pushdw EDX  ; Save EDX
            mul ECX     ; Shift decimal
            popdw EDX   ; Restore EDX after mul (discard high dword)
            sub BL, 48  ; 48 == '0'
            add EAX, EBX

            ; Increment & reiterate
            add EDX, 1
            jmp __atoi_loop

        __atoi_end:
            popdw EDX
            popdw ECX
            popdw EBX
            popdw RP
            ret

